import FlagBuilder

// create tasks for subprojects
subprojects { subproject ->
  // get right configuration for the subproject
  def config = rootProject.ext.configMap["$subproject.name"]

  ///////////////////////////////////////////////////////////////////////////

  task landmarksTongue {
    description = "Computes tongue landmarks files usable by the template matching."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    // source and destination directories
    def srcFile = file("$landmarksTongueDir/$scanPath/landmarks.json")
    def destFile = file("$rootProject.buildDir/$scanPath/landmarksTongue/landmarks.json")
    def templateLandmarksFile = file("$rootProject.buildDir/landmarksTongue.json")
    def scanFile = file("$mriDir/$scanPath/scan.json")

    // landmarksTongue depends on the createTongueTemplateLandmarks task
    dependsOn rootProject.createTongueTemplateLandmarks

    inputs.files srcFile, templateLandmarksFile, scanFile
    outputs.file destFile

    doLast{

      destFile.parentFile.mkdirs()
      def slurper = new groovy.json.JsonSlurper()

      // open spacings of scan
      def spacings = slurper.parse(scanFile).spacings

      // open template landmarks
      def templateLandmarks = slurper.parse(templateLandmarksFile)

      // open user landmarks
      def userLandmarks = slurper.parse(srcFile)

      // construct landmark correspondences list
      def landmarks = []

      templateLandmarks.each{ mark ->
        def found = userLandmarks.find{
          it.name == mark.name
        }
        if ( found != null) {
          // fuse landmark information
          landmarks << [
            name: found.name,
            sourceIndex: mark.index,
            sourceX : mark.X,
            sourceY : mark.Y,
            sourceZ : mark.Z,
            // scale target positions according to the spacings
            targetX: found.x.toDouble() * spacings.x.toDouble(),
            targetY: found.y.toDouble() * spacings.y.toDouble(),
            targetZ: found.z.toDouble() * spacings.z.toDouble(),
          ]
        }
      }

      // build json file
      def json = new groovy.json.JsonBuilder(landmarks)

      destFile.withWriter{
        it << json.toPrettyString()
      }

    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task matchTongue {
    description = "Performs template matching for the tongue."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    def pointCloud = file("$rootProject.buildDir/$scanPath/segmentTongue/point_cloud.obj")

    // landmarks, file does not need to exist
    def landmarkFile = file("$rootProject.buildDir/$scanPath/landmarksTongue/landmarks.json")
    def destDir = file("$rootProject.buildDir/$scanPath/matchTongue")

    // template file
    // def templateFile  = file("$rootProject.buildDir/$scanPath/alignTongueTemplate/alignedTemplate.ply")
    def templateFile  = file("$templateDir/${tongueTemplateName}.ply")

    // matchTongue depends on the landmarksTongue, and alignTongueTemplate task
    dependsOn "landmarksTongue"

    inputs.file pointCloud
    outputs.dir destDir

    doLast{
      destDir.mkdirs()

      def flags = (new FlagBuilder()).build(config.speaker.matchTongue)

      flags.add("--source $templateFile")
      flags.add("--target $pointCloud")
      flags.add("--output tracking_org_result0.ply")
      flags.add("--performRigidAlignment")

      if( landmarkFile.exists() ) {
        flags.add("--landmarks $landmarkFile")
      }

      logger.debug("match-template ${flags.join(' ')}")

      exec{
        commandLine "match-template ${flags.join(' ')}".tokenize()
        workingDir destDir
      }


    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task projectTongue { task ->
    description = "Projects matched tongue to scan."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    // input
    def matched = file("$rootProject.buildDir/$scanPath/matchTongue/tracking_org_result0.ply")
    def tongueScan = file("$rootProject.buildDir/$scanPath/cropToVocalTract/vocaltract.json")

    // output
    def destDir = file("$rootProject.buildDir/$scanPath/$task.name")

    def projected = file("$destDir/projected.json")


    // projectTongue depends on the matchTongue task
    dependsOn "matchTongue"

    inputs.files matched, tongueScan
    outputs.file projected

    doLast{
      destDir.mkdirs()

      def command = "mesh-project --mesh $matched --scan $tongueScan --output $projected"
      logger.debug(command)
      exec{
        commandLine command.tokenize()
        workingDir rootProject.buildDir
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task segmentTongue { task ->

    description = "Segments a scan by using thresholding."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    def srcFile = file("$rootProject.buildDir/$scanPath/cropToVocalTract/vocaltract.json")
    def destDir = file("$rootProject.buildDir/$scanPath/$task.name")
    def segmentation = file("$destDir/segmentation.json")
    def cloudFile = file("$destDir/point_cloud.obj")

    // segmentTongue depends on the cropToVocalTract task
    def cropToVocalTract = ":projects:shared:$dataset.name-$speaker-$scan:cropToVocalTract"

    dependsOn cropToVocalTract

    def thresholdingType = config.speaker.segmentTongue.thresholdingType

    if(thresholdingType == "WITH LANDMARKS") {

        dependsOn ":projects:speaker:${dataset.name}-$speaker:estimateTongueThreshold"
        inputs.file file("$rootProject.buildDir/$dataset.name/$speaker/estimateTongueThreshold/threshold.json")

    }

    inputs.file srcFile
    outputs.file segmentation
    outputs.file cloudFile


    doLast{
      destDir.mkdirs()

      def command = ""

      switch(thresholdingType) {

        case "BASIC":

          def threshold = config.speaker.segmentTongue.threshold
              command = "threshold --input $srcFile --threshold $threshold --scale_to_8bit --output $segmentation --cloud $cloudFile"
          break

        case "OTSU":

          command = "otsu-threshold --input $srcFile --output $segmentation --cloud $cloudFile"
          break

        case "WITH LANDMARKS":

          def thresholdFile = file("$rootProject.buildDir/$dataset.name/$speaker/estimateTongueThreshold/threshold.json")

          def threshold = (new groovy.json.JsonSlurper()).parse(thresholdFile).threshold

          command = "threshold --input $srcFile --threshold $threshold --scale_to_8bit --output $segmentation --cloud $cloudFile"

          break

        case "WEIGHTED OTSU":

          def weightInside = config.speaker.segmentTongue.weightInside
          def weightOutside = config.speaker.segmentTongue.weightOutside

          command = "weighted-otsu-threshold --input $srcFile --weightInside ${weightInside} --weightOutside ${weightOutside} --output $segmentation --cloud $cloudFile"

          break


        default:

          throw new Exception("Unknown thresholding type.")
          break

      }

      logger.debug(command)
      logging.captureStandardOutput LogLevel.DEBUG
      exec{
        commandLine command.tokenize()
        workingDir rootProject.buildDir
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task visualizeTongueProjection { task ->

    description = "Projects matched tongue to scan."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    // input
    def projected = file("$rootProject.buildDir/$scanPath/projectTongue/projected.json")

    // raw landmarks in image coordinates
    def landmarksFile = file("${landmarksTongueDir}/$scanPath/landmarks.json")

    // output
    def destDir = file("$rootProject.buildDir/$scanPath/$task.name")

    // visualizeTongueProjection depends on the projectTongue task
    dependsOn "projectTongue"

    inputs.files projected, landmarksFile

    outputs.dir destDir

    doLast{
      destDir.mkdirs()

      def slurper = new groovy.json.JsonSlurper()
      def landmarks = slurper.parse(landmarksFile)

      // get three landmarks to use for slice selection
      def airway = landmarks.find{ it.name == "Airway" }
      def frontBase = landmarks.find{ it.name == "FrontBaseCenter" }
      def tip = landmarks.find{ it.name == "Tip" }
      def surface = landmarks.find{ it.name == "SurfaceCenter" }

      // get boundary coordinate values in z-direction
      int maxZ = config.speaker.cropToVocalTract.maxZ.toInteger()
      int minZ = config.speaker.cropToVocalTract.minZ.toInteger()

      // get minimum values for x and y
      int minX = config.speaker.cropToVocalTract.minX.toInteger()
      int minY = config.speaker.cropToVocalTract.minY.toInteger()


      // use landmarks to select slices, also shift origin
      int centerX = ( airway.x.toInteger() + frontBase.x.toInteger() - 2 * minX ) / 2
      int frontX = ( surface.x.toInteger() + frontBase.x.toInteger() - 2 * minX ) / 2
      int backX = airway.x.toInteger() - minX
      int midwayX = ( centerX + backX ) / 2

      int bottomY = ( frontBase.y.toInteger() - minY)
      int centerY = ( tip.y.toInteger() - minY)
      int midwayY = ( centerY + bottomY) / 2
      int topY = (surface.y.toInteger() - minY)

      // use slice in the middle along z-axis and two at the sides
      int centerZ = (maxZ - minZ ) / 2

      // extract slices
      exec{
        commandLine "extract-slice --input $projected --xy ${centerZ - 10} ${centerZ} ${centerZ + 10}\
                     --xz ${bottomY} ${centerY} ${midwayY} ${topY} --yz ${frontX} ${centerX} ${midwayX} ${backX} --output $destDir/slice".tokenize()
        workingDir rootProject.buildDir
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////

}
